----------------------------------------------------------------------------------------------------
*****************************Sorting Algorithm********************************
----------------------------------------------------------------------------------------------------
1) Bubble Sort
#include<iostream>

using namespace std;

int main()
{
	int a[20];
	int n;
	int i,j,tmp;
	cout<<"*** Bubble Sort ***";
	cout<<"Enter size of the array: ";
	cin>>n;
	cout<<"Enter elements in the array: ";
	for(i=0; i<n; i++)
	{
		cin>>a[i];
	}
	cout<<"Before Sorting: "<<endl;
	for(i=0;i<n;i++)
	{
		cout<<a[i]<<" ";
	}
	
	
	//Bubble Sort
	for(i=0; i<n-1; i++)
	{
		for(j=i+1; j<n; j++)
		{
			if(a[i]>a[j])
			{
				tmp = a[i];
				a[i] = a[j];
				a[j] = tmp;
			}
		}
	}
	
	cout<<"\n\nAfter Sorting: "<<endl;
	for(i=0; i<n; i++)
	{
		cout<<a[i]<<" ";
	}
}
----------------------------------------------------------------------------------------------------
2) Selection Sort
#include<iostream>

using namespace std;

int main()
{
	int n,a[20];
	int i,j,tmp,min,loc;
	cout<<"Selection Sort"<<endl;
	cout<<"Enter size of the array: ";
	cin>>n;
	cout<<"Enter elements in the array: ";
	for(i=0; i<n; i++)
	{
		cin>>a[i];
	}
	cout<<"Before Sorting: "<<endl;
	for(i=0; i<n; i++)
	{
		cout<<a[i]<<" ";
	}
	
	//min and loc
	for(i=0; i<n-1; i++)
	{
		min = a[i];
		loc = i;
		for(j=i+1; j<n; j++)
		{
			if(a[j]<min)
			{
				min = a[j];
				loc = j;
			}
		}
		//Swap i and loc
		tmp = a[i];
		a[i] = min;
		a[loc] = tmp;
	}
	cout<<"\n\nAfter Sorting: "<<endl;
	for(i=0; i<n; i++)
	{
		cout<<a[i]<<" ";
	}
}
----------------------------------------------------------------------------------------------------
3) Insertion Sort
#include<iostream>

using namespace std;

int main()
{
	int n,a[20];
	int i,loc,tmp;
	cout<<"Insertion Sort"<<endl;
	cout<<"Enter size of the array: "<<endl;
	cin>>n;
	cout<<"Enter elements in the array: "<<endl;
	for(i=0; i<n; i++)
	{
		cin>>a[i];
	}
	cout<<"Before Sorting: "<<endl;
	for(i=0; i<n; i++)
	{
		cout<<a[i]<<" ";
	}
	//Insertion sort
	for(i=1; i<n; i++)
	{
		tmp = a[i];
		loc = i-1;
		while(tmp<a[loc] && loc>=0)
		{
			a[loc+1] = a[loc];
			loc--;
		}
		a[loc+1] = tmp;
	}
	
	cout<<"\n\nAfter Sorting: "<<endl;
	for(i=0; i<n; i++)
	{
		cout<<a[i]<<" ";
	}
}
----------------------------------------------------------------------------------------------------
4) Shell Sort
#include<iostream>
#include<math.h>

using namespace std;

int main()
{
	int n,a[20];
	int i,gap,loc,extractData;
	cout<<"Shell Sort"<<endl;
	cout<<"Enter size of the array: "<<endl;
	cin>>n;
	cout<<"Enter elements in the array: "<<endl;
	for(i=0; i<n; i++)
	{
		cin>>a[i];
	}
	cout<<"Before Sorting: "<<endl;
	for(i=0; i<n; i++)
	{
		cout<<a[i]<<" ";
	}
	//Shell sort
	gap=floor(n/2);
	while(gap>0)
	{
		for(i=0; i<n-gap; i++)
		{
			extractData = a[i+gap];
			loc = i+gap;
			while((loc-gap)>=0 && extractData<a[loc-gap])
			{
				a[loc] = a[loc-gap];
				loc = loc-gap;
			}
			a[loc] = extractData;
		}
		gap = floor(gap/2);
	}
	
	cout<<"\n\nAfter Sorting: "<<endl;
	for(i=0; i<n; i++)
	{
		cout<<a[i]<<" ";
	}
}
----------------------------------------------------------------------------------------------------
5)Radix Sort
#include<iostream>

using namespace std;

int main()
{
	int i,j,n,r,k,p,arr[20];
	int max,passes = 0;
	int bucket[10][20];
	int b_count[10];
	int divisor = 1;
	cout<<"Radix Sort"<<endl;
	cout<<"Enter size of the array: "<<endl;
	cin>>n;
	cout<<"Enter elements in the array: "<<endl;
	for(i=0; i<n; i++)
	{
		cin>>arr[i];
	}
	cout<<"Before Sorting: "<<endl;
	for(i=0; i<n; i++)
	{
		cout<<arr[i]<<" ";
	}
	
	//Find maximum element
	max = arr[0];
	for(i=1; i<n; i++)
	{
		if(arr[i]>max)
		{
			max = arr[i];
		}
	}
	
	//Find the number of digits
	while(max>0)
	{
		passes++;
		max = max/10;
	}
	
	//Radix Sort
	for(p=1; p<=passes; p++)
	{
		//Inititalize b_count to 0
		for(k=0; k<10; k++)
		{
			b_count[k] = 0;
		}
		
		//Extract digit, Place in bin, b_count increment
		for(i=0; i<n; i++)
		{
			r = (arr[i]/divisor)%10;
			bucket[r][b_count[r]] = arr[i];
			b_count[r]++;
		}
		
		//Collect the bins
		i = 0;
		for(j=0; j<10; j++)
		{
			for(k=0; k<b_count[j]; k++)
			{
				arr[i] = bucket[j][k];
				i++;
			}//end of k
		}//end of j
		divisor = divisor * 10;
	}//end of p
	cout<<"\n\nAfter Sorting: "<<endl;
	for(i=0; i<n; i++)
	{
		cout<<arr[i]<<" ";
	}	
}
----------------------------------------------------------------------------------------------------
Searching Algorithum
----------------------------------------------------------------------------------------------------
1)Binary Search
#include<iostream>
#include<math.h>

using namespace std;

int main()
{
	int i,arr[20],n,target;
	int first,mid,last,flag;
	cout<<"Binary Search"<<endl;
	cout<<"Enter size of the array: "<<endl;
	cin>>n;
	cout<<"Enter elements in the array: "<<endl;
	for(i=0; i<n; i++)
	{
		cin>>arr[i];
	}
	cout<<"Enter value to search: "<<endl;
	cin>>target;
	flag=0;
	first=0;
	last=n-1;
	while(first<=last)
	{
		mid = floor(first+last)/2;
		if(target<arr[mid])
		{
			last = mid-1;
		}
		else if(target>arr[mid])
		{
			first = mid+1;
		}
		else
		{
			flag=1;
			break;
		}	
	}
	if(flag==1)
	{
		cout<<"\nTarget found at index: "<<mid;
	}
	else
	{
		cout<<"\nTarget not found!";
	}
}
}
----------------------------------------------------------------------------------------------------
2)Linear Search/Sequential Search
#include<iostream>

using namespace std;

int main()
{
	int i,target,n,flag;
	int arr[20];
	cout<<"Linear Search"<<endl;
	cout<<"Enter size of the array: "<<endl;
	cin>>n;
	cout<<"Enter elements in the array: "<<endl;
	for(i=0; i<n; i++)
	{
		cin>>arr[i];
	}
	cout<<"Enter value to search: "<<endl;
	cin>>target;
	flag=0;
	for(i=0; i<n; i++)
	{
		if(arr[i] == target)
		{
			flag=1;
			break;
		}
	}
	if(flag==1)
	{
		cout<<"\nTarget found at index: "<<i;
	}
	else
	{
		cout<<"\nTarget not found!";
	}
}
----------------------------------------------------------------------------------------------------Linked List
----------------------------------------------------------------------------------------------------
1)Singly Linked List

#include<iostream>
#include<conio.h>
using namespace std;
/*1) Node template*/
class Node
{
public:
int data;
Node *next;
};
//2) List Template
class list
{
Node *head;
public:
List()
{
head=NULL;
}
void Insert(int x);
void Display();
void Length();
void Search(int x);
void Remove(int x);
void Reverse();
};
/*3) Functions*/
void list::Insert(int x)
{
//create a node
Node *t=new Node();
t->data=x;
t->next=NULL;
//If list is Empty
if(head==NULL)
{
head=t;
return;
}
//Tarverse till the last node and attach it
Node *tmp=head;
while(tmp->next !=NULL)
{
tmp=tmp->next;
}
//attach t to tmp
tmp->next=t;
}
void list::Display()
{
Node *tmp=head;
while(tmp!=NULL)
{
cout<<tmp->data<<"->";
tmp=tmp->next;
}
cout<<"NULL";
}
void list::Length()
{
Node *tmp=head;
int cnt=0;
while(tmp!=NULL)
{
cnt++;
tmp=tmp->next;
}
cout<<"Number of Nodes: "<<cnt;
}
void list::Search(int x)
{
Node *tmp=head;
int flag=0;
while(tmp!=NULL)
{
if(tmp->data==x)
{
flag=1;
break;
}
tmp=tmp->next;
}
if(flag==1)
{
cout<<x<<" is found in the list " ;
}
else
{
cout<<x<<" is not found in the list " ;
}
}
void list::Remove(int x)
{
 //Step 1:Empty List-Return Conttrol
 if(head==NULL)
 {
 cout<<"Empty List: ";
 return;
 }
 //Step 2:Search for x
 Node *tmp=head;
 int flag=0;
 Node *prev=NULL;

 while(tmp!=NULL)
 {
 if(tmp->data==x)
 {
 flag=1;
break;
 }

 prev=tmp;
 tmp=tmp->next;
 }
 //Setp 3:Unsuccesful Search-RETURN CONTROL
if (flag==0)
{
cout<<x<<" is not found in the list.";
return;
}
//Step 4:Search is successful
//Step 4a:Single node deletion
 if(tmp==head && tmp->next==NULL)
 {
 head=NULL;
}
else if(tmp==head) //Step 4a:Head node deletion
{
head= tmp->next;
}
else if(tmp->next==NULL) //Step 4a:tail node deletion
{
prev->next=NULL;
}
else //Step 4a:Sny other node deletion
{
prev->next=tmp->next;
}
//Step 5:Delete tmp
delete tmp;
}
void list::Reverse()
{
if(head==NULL)
{
cout<<"Empty List";
return;
}
Node *tmp=head;
Node *revHead=NULL;
while(tmp!=NULL)
{
//make a new Node
Node *r=new Node();
r->data=tmp->data;
r->next=revHead;//for the 1st node revHead is NULL
//Update revHead
revHead=r;
//Advance tmp to teh next node
tmp=tmp->next;
}
//update head to revHead
head=revHead;
cout<<endl<<"Reverse Head";
list::Display();
}

/*4) Menu*/
int main()
{
int ch;
int num;
list s;
while(1)
 {
system("cls");
cout<<"** Singly linked list menu" <<endl;
cout<<"1.Insert the node" <<endl;
cout<<"2.Display the list" <<endl;
cout<<"3.Length of the list" <<endl;
cout<<"4.Search for node" <<endl;
cout<<"5.remove node" <<endl;
cout<<"6.Reverse the list" <<endl;
cout<<"7.Exit" <<endl;
cout<<"Enter your choice:"<<endl<<endl;
cin>>ch;
switch(ch)
{
case 1:
cout<<"Enter The Element :";
cin>>num;
s.Insert(num);
getch();
break;
case 2:
s.Display();
getch();
break;
case 3:
s.Length();
getch();
break;
case 4:
cout<<"Enter the element for Search : ";
cin>>num;
s.Search(num);
getch();
break;
case 5:
cout<<"Enter the element to be deleted:
";
cin>>num;
s.Remove(num);
s.Display();
getch();
break;
case 6:
s.Reverse();
getch();
break;
case 7:
exit(1);
default:
cout<<"Incorrect Option";
getch();
}//end of switch
}//end of while
}//end of main
----------------------------------------------------------------------------------------------------
2)Doubly Linked List
#include<iostream>
#include<conio.h>
using namespace std;
/*1) Node template */
class DNode
{
public:
int data;
DNode *right;
DNode *left;
};
/*2) List template*/
class DList{
DNode *head;
DNode *tail;
public:
DList()
{
head = NULL;
tail = NULL;
}
void Insert(int x);
void Display();
void Length();
void Search(int x);
void Remove(int x);
};
/*3) Function */
void DList::Insert(int x)
{
//make a new node
DNode *t=new DNode();
t->data=x;
t->right=NULL;
t->left=NULL;
//Head Node
if(head==NULL)
{
head=t;
tail=t;
}
else //attach t to tail,and shift tail
{
tail->right=t;
t->left=tail;
tail=t;
}
}
void DList::Display()
{
if(head==tail){
cout<<"Empty List";
return;
}
cout<<"Forward Direction";
DNode *tmp=head;
while(tmp!=NULL)
{
cout<<tmp->data<<"<->";
tmp=tmp->right;
}
cout<<"End of List"<<endl<<endl;
cout<<"ReversDirection";
tmp=tail;
while(tmp!=NULL)
{
cout<<tmp->data<<"<->";
tmp=tmp->left;
}
cout<<"Start of List"<<endl<<endl;
}
void DList::Length()
{
int cnt=0;
DNode *tmp=head;
while(tmp!=NULL)
{
cnt++;
tmp=tmp->right;
}
cout<<" Length of the List : "<<cnt;
}
void DList::Search(int x)
{
DNode *tmp=head;
int flag=0;
while(tmp!=NULL)
{
if(tmp->data==x)
{
flag=1;
break;
}
tmp=tmp->right;
}
if(flag==1)
{
cout<<x<<" is found in the list " ;
}
else
{
cout<<x<<" is not found in the list " ;
}
}
void DList::Remove(int x)
{
//Empty list return Control
if(head==NULL)
{
cout<<"Empty List";
return;
}
DNode *tmp=head;
DNode *prev=NULL;
int flag =0;
while(tmp!=NULL)
{
if(tmp->data==x)
{
flag=1;
break;
}
prev=tmp;
tmp=tmp->right;
}
//3.
if (flag==0)
{
cout<<x<<"is not found in the list";
return;
}
//4. Search Successful
//4a.Single node deletion
if(head==tail)
{
head=NULL;
tail=NULL;
}
//4b Head node deletion
else if(tmp==head)
{
head=tmp->right;
head->left=NULL;
}
//4c.Tail node deletion
else if(tmp==tail)
{
 tail=prev;
 tail->right=NULL;
}
//4d. Any other node in the deletion
else
{
prev->right=tmp->right;
(tmp->right)->left=prev;
}
//5.Delete tmp
delete tmp;
DList::Display();
}
/*4) Menu Interface*/
int main()
{
int ch;
int num;
DList d;
while(1)
{
system("cls");
cout<<"*****Doubly_List*****"<<endl<<endl;
cout<<"1.Insert a node"<<endl;
cout<<"2.Display the list"<<endl;
cout<<"3.Length of the list"<<endl;
cout<<"4.Search for a node"<<endl;
cout<<"5.Remove a node"<<endl;
cout<<"6.Exit"<<endl<<endl;
cout<<"Enter your choice"<<endl<<endl;
cin>>ch;
switch(ch)
{
case 1:
cout<<"Enter an Element: "<<endl;
cin>>num;
d.Insert(num);
getch();
break;
case 2:
 d.Display();
getch();
break;
case 3:
d.Length();
getch();
break;
case 4:
cout<<"Enter the element for Search : ";
cin>>num;
d.Search(num);
getch();
break;
case 5:
cout<<"Enter the element for delete : ";
cin>>num;
d.Remove(num);
getch();
break;
case 6:
exit(1);
default:
cout<<"Incorrect Option ";
getch();
break;
}//end of switch
}//end of while
}//end of main
----------------------------------------------------------------------------------------------------
3)Circular Linked List

#include<iostream>
#include<conio.h>
using namespace std;
/*1) Node template */
class CNode
{
public:
int data;
CNode *next;
};
/*2) List template*/
class CList
{
CNode *first;
CNode *last;
public:
CList()
{
first = NULL;
last = NULL;
}
void Insert(int x);
void Display();
void Length();
void Search(int x);
void Remove(int x);
};
/*3) Function*/
void CList :: Insert(int x)
{
//make a new node
CNode *t=new CNode();
t->data=x;
t->next=NULL;
if(first==NULL && last== NULL) //if list is null
{
first=t;
last=t;
last->next=first; //last next (add) pointing to first (element)
}
else //if list is not null
{
last->next=t;
last=t; //linking last next to new element
last->next=first; //making it circular
}
}
void CList::Display()
{
if (first == NULL)
{
cout<<"Empty List";
return;
}
CNode *tmp=first; //pointing to first node
do
{
cout<< tmp->data<<"->"; //print first node without
checking condition
tmp=tmp->next; //
}
while(tmp!=first);//tmp has not come back to first (if tmp
pointing to the first terminate)
cout<<" back to first";
}
void CList::Length()
{
if (first == NULL)
{
cout<<"Empty List";
return;
}
CNode *tmp=first; //pointing to first node
int cnt=0;
do
{
cnt++;
tmp=tmp->next;
}
while(tmp!=first);
cout<<" Number Of Nodes : "<<cnt;
}

void CList::Search(int x)
{
if (first==NULL)
{
cout<<" Empty list";
return;
}
CNode *tmp=first;
int flag=0;
do
{
if(tmp->data==x)
{
flag=1;
break;
}
tmp=tmp->next;
}
while(tmp!=first);
if(flag==1)
{
cout<<x<<" is found in the list " ;
}
else
{
cout<<x<<" is not found in the list " ;
}
}
void CList::Remove(int x)
{
//1.Empty list -RETURN CONTROL
if(first==NULL)
{
cout<<"Empty List";
return;
}
//2.Search for x
CNode *tmp=first;
CNode *prev=NULL;
int flag =0;
do
{
if(tmp->data==x)
{
flag=1;
break;
}
prev=tmp;
tmp=tmp->next;
}
while(tmp!=first);
//3. Search unsuccesssful -RETURN CONTROL
if(flag==0)
{
cout<<x<<" is not found in the list";
return;
}
//4. Search Successful
//4a.Single node deletion
if(first==last)
{
first=NULL;
last=NULL;
}
else if(tmp==first) //4b First node deletion
{
first=tmp->next;
last->next=first;
}
else if(tmp==last) //4c.Last node deletion
{
 last=prev;
 last->next=first;
}
else //4d. Any other node in the deletion
{
prev->next=tmp->next;
}
//5.Delete tmp
delete tmp;
CList::Display();
}
/*4) Menu*/
int main()
{
int ch;
int num;
CList c;
while(1)
{
system("cls");
cout<<"*****Circular_List*****"<<endl<<endl;
cout<<"1.Insert a node"<<endl;
cout<<"2.Display the list"<<endl;
cout<<"3.Length of the list"<<endl;
cout<<"4.Search for a node"<<endl;
cout<<"5.Remove a node"<<endl;
cout<<"6.Exit"<<endl<<endl;
cout<<"Enter your choice"<<endl<<endl;
cin>>ch;
switch(ch)
{
case 1:
cout<<"Enter an Element: "<<endl;
cin>>num;
c.Insert(num);
getch();
break;
case 2:
 c.Display();
getch();
break;
case 3:
c.Length();
getch();
break;
case 4:
cout<<"Enter the element for Search : ";
cin>>num;
c.Search(num);
getch();
break;
case 5:
cout<<"Enter the element for delete : ";
cin>>num;
c.Remove(num);
getch();
break;
case 6:
exit(1);
default:
cout<<"Incorrect Option ";
getch();
break;
}//end of switch
}//end of while
}//end of main
----------------------------------------------------------------------------------------------------
Stack
----------------------------------------------------------------------------------------------------
1)Stack using Array

#include<iostream>
#include<conio.h>
#define MAX 5
using namespace std;
/* 1)Node Template- Not Required */
/* 2)Stack Template */
class AStack
{
int a[MAX];
int tos;
public:
AStack()
{
tos=-1;
}
void Push(int x);
void pop();
void peek();
void Display();
int Full();
int Empty();
};
/* 3)Funcation */
void AStack::Push(int x)
{
if(Full())
{
cout<<"Stack Overflow !"<<endl;
}
else
{
tos++;
a[tos]=x;
}
}
int AStack::Full()
{
if(tos==MAX-1)
{
return 1;
}
else
{
return 0;
}
}
void AStack::pop()
{
if(Empty())
{
cout<<"Stack Underflow"<<endl;
}
else
{
int t=a[tos];
tos--;
cout<<"Element popped is "<<t<<endl;
}
}
int AStack::Empty()
{
if(tos== -1)
{
return 1;
}
else
{
return 0;
}
}
void AStack::peek()
{
if(Empty())
{
cout<<"Stack Underflow";
}
else
{
cout<<"Element at "<<a[tos];
}
}
void AStack::Display()
{
if(Empty())
{
cout<<"Stack Underflow";
}
else
{
for(int i=tos ;i>=0 ;i--)
{
cout<<a[i]<<endl;
}
}
}
/* 4)Menu */
int main()
{
int ch,num;
AStack s;
while(1)
{
system("cls");
cout<<"***Array Based Stack***"<<endl<<endl;
cout<<"1.Push an element"<<endl;
cout<<"2.Pop an element "<<endl;
cout<<"3.Peek at the stack"<<endl;
cout<<"4.Display the stack"<<endl;
cout<<"5.Exit"<<endl;
cout<<"Enter Your choice : "<<endl;
cin>>ch;
switch(ch)
{
case 1:
cout<<"Enter a value : ";
cin>>num;
s.Push(num);
getch();
break;
case 2:
cout<<"Enter element to pop:";
s.pop();
getch();
break;
case 3:
cout<<"peek at stack ";
s.peek();
getch();
break;
case 4:
cout<<" Display ";
s.Display();
getch();
break;
case 5:
exit(1);
default:
cout<<"Incorrect otn";
getch();
break;
}//end of switch
}//end of while
}//end of main
----------------------------------------------------------------------------------------------------
Stack Using List

#include<iostream>
#include<conio.h>
using namespace std;
/* 1)Node Template*/
class SNode
{
public:
int data;
SNode *next;
};
/* 2)Stack Template */
class LStack
{
SNode *tos;
public:
LStack()
{
 tos==NULL;
}
void Push(int x);
void pop();
void peek();
void Display();
int Full();
int Empty();
};
/* 3)Funcation */
void LStack::Push(int x)
{
//Make a node
SNode *t=new SNode();
t->data= x;
t->next=NULL;
//First Node
if(tos==NULL)
{
tos=t;
}
else //Insert at end
{
t->next=tos;
tos=t;
}
}
void LStack::pop()
{
if(tos==NULL)
{
cout<<"Stack OverFlow";
}
else
{
SNode *t=tos;
tos=tos->next;
cout<<"Enter Popped is: "<<t->data;
delete t;
}
}
void LStack::peek()
{
if(tos==NULL)
{
cout<<"Stack Underflow!";
}
else
{
cout<<"Element at tos "<<tos->data;
}
}
void LStack::Display()
{
if(tos==NULL)
{
cout<<"Stack Underflow!";
}
else
{
SNode *tmp=tos;
while(tmp!=NULL)
{
cout<<tmp->data<<"->"<<endl;
tmp=tmp->next;
}
cout<<"NULL";
}
}
/* 4)Menu */
int main()
{
int ch,num;
LStack l;
while(1)
{
system("cls");
cout<<"***List Based Stack***"<<endl<<endl;
cout<<"1.Push an element"<<endl;
cout<<"2.Pop an element "<<endl;
cout<<"3.Peek at the List"<<endl;
cout<<"4.Display the List"<<endl;
cout<<"5.Exit"<<endl;
cout<<"Enter Your choice : "<<endl;
cin>>ch;
switch(ch)
{
case 1:
cout<<"Enter a value : ";
cin>>num;
l.Push(num);
getch();
break;
case 2:
cout<<"Enter element to pop:";
l.pop();
getch();
break;
case 3:
cout<<"peek at stack ";
l.peek();
getch();
break;
case 4:
cout<<" Display ";
l.Display();
getch();
break;
case 5:
exit(1);
default:
cout<<"Incorrect otn";
getch();
break;
}//end of switch
}//end of while
}//end of main
----------------------------------------------------------------------------------------------------
Balancing of Parenthesis
----------------------------------------------------------------------------------------------------
#include<iostream>
#define SIZE 20
using namespace std;
/*2.Stack Template*/
class Stack
{
char a[SIZE];
int tos;
public:
Stack()
{
tos=-1;
}
void Push(char x);
char Pop();
int Full();
int Empty();
};
/*3. Function*/
void Stack ::Push(char x)
{
if(Full())
{
cout<<"Stack Overflow";
}
else
{
tos++;
a[tos]=x;
}
}
char Stack::Pop()
{
if(Empty())
{
cout<<"Stack Overflow";
return -1;
}
else
{
char t =a[tos];
tos--;
return t;
}
}
int Stack::Full()
{
return (tos==SIZE-1?1:0);
}
int Stack::Empty()
{
return (tos==-1?1:0);
}
/* 4.Main Application*/
int main()
{
char expr[20],temp;
int i=0, flag=0;
Stack s;
system("cls");
cout<<"Program to check if the parenthesis balance in an expression \n";
cout<<"Enter an expression: ";
cin>>expr;
while(expr[i]!='\0')
{
if(expr[i]=='('|| expr[i]=='{'||expr[i]=='[')
{
s.Push(expr[i]);
}//end of open bracket
if(expr[i]==')'|| expr[i]=='}' ||expr[i]==']')
{
if(s.Empty())//Takes Care of extra bracket at end
{
flag=1;
break;
}
temp=s.Pop();
if( (temp=='('&& expr[i]==')')||
 (temp=='{'&& expr[i]=='}')||
 (temp=='['&& expr[i]==']') )

{
i++;
continue;
}
else //Brackets don't match
{
flag=1;
break;
}
}//end of close bracket
i++;
}//end of while
if(s.Empty()&& flag==0)
{
cout<<"Pranthesis are balanced ";
}
else
{
cout<<"Pranthesis are not balanced ";
}
}
----------------------------------------------------------------------------------------------------
Addition of Two Polynomial
----------------------------------------------------------------------------------------------------
#include<iostream>
#include<conio.h>
using namespace std;
/* 1. Node Template */
class PNode
{
public:
int coeff;
int exp;
PNode *next;
};
/* 2. List Template */
class PList
{
PNode *head;
public:
PList()
{
head = NULL;
}
 void Insert(int c, int e);
void Display();
void Add(PList p1, PList p2);
};
/* 3. Function */ //Insert
void PList :: Insert(int c, int e)
{
//Make a new Node
PNode *t = new PNode();
t->coeff = c;
t->exp = e;
t->next = NULL;
//First Node
if(head == NULL)
{
head = t;
return;
}
//Traverse and insert in order
PNode *tmp = head;
PNode *prev = NULL;
while(tmp != NULL && tmp->exp>e)
{
prev = tmp;
tmp = tmp->next;
}
//Head Node
if(tmp == head)
{
t->next = tmp;
head = t;
}
//Tail Node
else if(tmp == NULL)
{
prev->next = t;
}
//Any node in the middle
else
{
t->next = tmp;
prev->next = t; }
}
//Display
void PList :: Display()
{
if(head == NULL)
{
cout <<"Polynomial is empty.";
return;
}
PNode *tmp = head;
while(tmp!=NULL)
{
cout << tmp->coeff;
cout << "x^" << tmp->exp;
if(tmp->next != NULL)
{
if((tmp->next)->coeff > 0)
{
cout << " +";
}
else
{
cout << " ";
}
}
tmp=tmp->next;
}
}
//Add
void PList :: Add(PList p1, PList p2)
{
PNode *P=p1.head;
PNode *Q=p2.head;
int c,e;
while(P!=NULL && Q!=NULL)
{
if(P->exp == Q->exp)
{
c=P->coeff+Q->coeff;
if(c != 0)
{
e = P->exp;
Insert(c,e);
}
P=P->next;
Q=Q->next;
}//end of P->exp == Q->exp
else if(P->exp > Q->exp)
{
c=P->exp;
e=P->exp;
Insert(c,e);
P=P->next;
}//end of P->exp > Q->exp
else
{
c=Q->coeff;
 e=Q->exp;
Insert(c,e);
Q=Q->next;
}//end of Q->exp > P->exp }//end of while P&&Q != NULL
while(P!=NULL)
{
c=P->coeff;
e=P->exp;
Insert(c,e);
P=P->next;
}//end of while P is not NULL but Q is.
while(Q != NULL)
{
c=Q->coeff;
e=Q->exp;
Insert(c,e);
Q=Q->next;
}//end of while Q is not NULL but P is.
}
}
/* 4. Menu */
int main()
{
int ch, co, ex;
PList p1,p2,p3;
while(1)
{
system("cls");
cout << "*** Polynomial Function ***\n\n";
cout << "1. Read the first polynomial" << endl;
cout << "2. Read the second polynomial" << endl;
cout << "3. Display the first polynomial" << endl;
cout << "4. Display the second polynomial" << endl;
cout << "5. Add the polynomials" << endl;
cout << "6. Exit" << endl << endl;
cout << "Enter your choice: ";
cin >> ch;
switch(ch)
{
case 1:
cout << "Enter the coefficient: ";
cin >> co;
cout << "Enter the exponent: ";
cin >> ex;
p1.Insert(co,ex);
getch();
break;
case 2:
cout << "Enter the coefficient: ";
cin >> co;
cout << "Enter the exponent: ";
cin >> ex;
p2.Insert(co,ex);
getch();
break;
case 3:
p1.Display();
getch();
break;
case 4:
p2.Display();
getch();
break;
case 5:
p3.Add(p1,p2);
p3.Display();
getch();
break;
case 6:
exit(1);
default:
cout << "Enter a valid Option " << endl;
 getch();
 break;
}//end of switch
}//end of while
}//end of main
----------------------------------------------------------------------------------------------------
Evaluation of postfix operation
----------------------------------------------------------------------------------------------------
#include<iostream>
#include<conio.h>
#include<ctype.h>
#define SIZE 20
using namespace std;
/*2.Stack Template*/
class Stack
{
float a[SIZE];
int tos;
public:
Stack()
{
tos=-1;
}
void Push(float x);
float Pop();
int Full();
int Empty();
};
/*3. Function*/
void Stack ::Push(float x)
{
if(Full())
{
cout<<"Stack Overflow";
}
else
{
tos++;
a[tos]=x;
}
}
float Stack::Pop()
{
if(Empty())
{
cout<<"Stack Overflow";
return -1;
}
else
{
char temp =a[tos];
tos--;
return temp;
}
}
int Stack::Full()
{
return (tos==SIZE-1 ? 1:0);
}
int Stack::Empty()
{
return (tos==-1 ? 1:0);
}
Evaluation of postfix Expression

#include "postfix_operation.cpp"
int main()
{
char postfix[20],temp,i;
float a,b,result;
Stack s;
cout<<"***Evaluation of postfix expression***\n";
cout<<"Enter a postfix expression: ";
gets(postfix);
while(postfix[i]!='\0')
{
temp=postfix[i];
if(temp==' ')
{
i++;
continue;
}
if(isdigit(temp))
{
float x;
x=temp-48.0;
s.Push(x);
}
else //Operator
{
b=s.Pop();
a=s.Pop();
switch(temp)
{
case '+':
result=a+b;
break;
case '-':
result=a-b;
break;
case '*':
result=a*b;
break;
case '/':
result=a/b;
break;
}//end of switch
s.Push(result);
}//end of else
i++;
}//end of while
result=s.Pop();
cout<<"result of evalluation is: "<<result;
}//end of main
----------------------------------------------------------------------------------------------------
Queue
----------------------------------------------------------------------------------------------------
1)Ordinary Queue
#include<iostream>
#include<conio.h>
#define MAX 5
using namespace std;
// 1. Node Template - NOT REQUIRED
// 2. Queue Template
class OQueue
{
int a[MAX];
int front, rear;
public:
OQueue()
{
front = -1;
rear = -1;
}
void Enqueue(int x);
void Dequeue();
void PeekFront();
void PeekRear();
void Display();
int Full();
int Empty();
};
// 3. Function
//Enqueue
void OQueue :: Enqueue(int x)
{
if(Full())
{
cout << "Queue overflow!" << endl;
return;
}
if(front == -1)
{
front ++;
}
rear ++;
a[rear]=x;
}
//FULL
int OQueue :: Full()
{
return(rear==MAX-1?1:0);
}
void OQueue :: Dequeue()
{
if(Empty())
{
cout << "Queue Underflow!";
return;
}
int t = a[front];
if(front == rear) // Single element
{
front = -1;
rear = -1;
}
else
{
front ++;
}
cout << "Element removed is: " << t;
}
int OQueue :: Empty()
{
if(front == -1)
{
return 1;
}
else
{
return 0;
}
}
void OQueue :: PeekFront()
{
if(Empty())
{
cout << "Queue UnderFlow";
return;
}
cout << "Element at fornt is: " << a[front];
}
void OQueue :: PeekRear()
{
if(Empty())
{
cout << "Queue UnderFlow";
return;
}
cout << "Element at Rear is: " << a[rear];
}
void OQueue :: Display()
{
if(Empty())
{
cout << "Queue Underflow!";
}
for(int i = front; i <= rear; i++)
{
cout << a[i] << " ";
}
}
// 4. Menu
int main()
{
int ch, num;
OQueue q;
while(1)
{
system("cls");
cout << "*** Ordinary Queue ***\n\n";
cout << "1. Enqueue an element" << endl;
cout << "2. Dequeue an element" << endl;
cout << "3. Peek Front" << endl;
cout << "4. Peek Rear" << endl;
cout << "5. Display Queue" << endl;
cout << "6. Exit" << endl;
cout << "Enter your choice: ";
cin >> ch;
switch(ch)
{
case 1:
cout << "Enter an Element: ";
cin >> num;
q.Enqueue(num);
getch();
break;
case 2:
q.Dequeue();
getch();
break;
case 3:
q.PeekFront();
getch();
break;
case 4:
q.PeekRear();
getch();
break;
case 5:
q.Display();
getch();
break;
case 6:
exit(1);
default:
cout << "Incorect Choice!" << endl;
getch();
break;
}
}
}
----------------------------------------------------------------------------------------------------
2)Circular Queue
#include<iostream>
#include<conio.h>
#define MAX 5
using namespace std;
/* Node template */
/* Queue Template */
class CQueue
{
int a[MAX];
int front, rear;
int cnt;
public:
CQueue()
{
front = rear = -1;
cnt = 0;
}
void Enqueue(int x);
void Dequeue();
void PeekFront();
void PeekRear();
void Display();
int Full();
int Empty();
};
/* Function */
void CQueue :: Enqueue(int x)
{
if(Full())
{
cout << "Queue Overflow!";
return;
}
//First element in the queue
if(front == -1)
{
front ++;
}
rear = (rear + 1)%MAX;
a[rear] = x;
cnt ++;
}
int CQueue :: Full()
{
if(cnt == MAX)
{
return 1;
}
else
{
return 0;
}
}
void CQueue :: Dequeue()
{
if(Empty())
{
cout << "Queue Underflow!";
return;
}
int t = a[front];
if(front == rear) //Single Element
{
front = -1;
rear = -1;
}
else
{
front = (front + 1)%MAX;
}
cout << "Element removed is: " << t;
cnt --;
}
int CQueue :: Empty()
{
if(cnt == 0)
{
return 1;
}
else
{
return 0;
}
}
void CQueue :: PeekFront()
{
if(Empty())
{
cout << "Queue UnderFlow";
return;
}
cout << "Element at fornt is: " << a[front];
}
void CQueue :: PeekRear()
{
if(Empty())
{
cout << "Queue UnderFlow";
return;
}
cout << "Element at Rear is: " << a[rear];
}
void CQueue :: Display()
{
if(Empty())
{
cout << "Queue Underflow!";
return;
}
int x,i = front;
for(x = 1; x<=cnt; x++)
{
cout << a[i] << " ";
i = (i+1)%MAX;
}
}
/* Menu */
int main()
{
int ch, num;
CQueue c;
while(1)
{
system("cls");
cout << "*** Circular Queue ***\n\n";
cout << "1. Enqueue an element" << endl;
cout << "2. Dequeue an element" << endl;
cout << "3. Peek Front" << endl;
cout << "4. Peek Rear" << endl;
cout << "5. Display Queue" << endl;
cout << "6. Exit" << endl;
cout << "Enter your choice: ";
cin >> ch;
switch(ch)
{
case 1:
cout << "Enter an Element: ";
cin >> num;
c.Enqueue(num);
getch();
break;
case 2:
c.Dequeue();
getch();
break;
case 3:
c.PeekFront();
getch();
break;
case 4:
c.PeekRear();
getch();
break;
case 5:
c.Display();
getch();
break;
case 6:
exit(1);
default:
cout << "Incorect Choice!" << endl;
getch();
break;
}
}
}
----------------------------------------------------------------------------------------------------
3)Double-Ended Queue
/*
Name: Sejal Desai
 Roll No. : 1310
 UNIT 3: Queues
 PROGRAM : Double-Ended Queue
*/
#include<iostream>
#include<conio.h>
using namespace std;
/*1.NOde template*/
class DQNode
{
public:
int data;
DQNode *right;
DQNode *left;
};
/*2. Double Ended Queue*/
class DQueue
{
DQNode *front;
DQNode *rear;
public:
DQueue()
{
front=NULL;
rear=NULL;
}
void EnqueueFront(int x);
void EnqueueRear(int x);
void DequeueFront();
void DequeueRear();
void PeekFront();
void PeekRear();
void Display();
};
/*3. Function*/
void DQueue::EnqueueFront(int x)
{
//Make a new Node
DQNode *t=new DQNode();
t->data =x;
t->right =NULL;
t->left=NULL;
//First Node in Queue
if(front ==NULL)
{
front=t;
rear=t;
}
else //Any other Node
{
t->right =front;
front->left=t;
front =t;
}
}
void DQueue::EnqueueRear(int x)
{
//Make a new Node
DQNode *t=new DQNode();
t->data =x;
t->right =NULL;
t->left=NULL;
//First Node in Queue
if(front==NULL)
{
front=t;
rear=t;
}
else //Any other Node
{
rear->right =t;
t->left=rear;
rear =t;
}
}
void DQueue::Display()
{
if(front==NULL)
{
cout<<"Queue Underflow !";
return;
}
DQNode *tmp=front;
while(tmp != NULL)
{
cout<<tmp->data <<"<->";
tmp =tmp->right;
}
cout<<"NULL";
}
void DQueue ::DequeueFront()
{
//Empty
if(front==NULL)
{
cout<<"Queue Underflow !";
return;
}
DQNode *tmp=front;
if (front==rear) //Single node Deletion
{
front=NULL;
rear=NULL;
}
else //any other Node
{
front=front->right;
front->left =NULL;
}
cout<<"Element removed: "<<tmp->data;
delete tmp;
}
void DQueue :: DequeueRear()
{
//Empty
if(front==NULL)
{
cout<<"Queue Underflow !";
return;
}
DQNode *tmp=rear;
if (front==rear) //Single node Deletion
{
front=NULL;
rear=NULL;
}
else //any other Node
{
rear=rear->left;
rear->right =NULL;
}
cout<<"Element removed: "<<tmp->data;
delete tmp;
}
void DQueue :: PeekFront()
{
//Empty
if (front==NULL)
{
cout<<"UnderFlow !";
return;
}
cout<<"Element at the Front"<<front->data;
}
void DQueue :: PeekRear()
{
//Empty
if (front==NULL)
{
cout<<"UnderFlow !";
return;
}
cout<<"Element at the Rear "<<rear->data;
}
/*4. Menu*/
int main()
{
int ch,num;
DQueue d;
while(1)
{
system("cls");
cout << "*** Double-Ended Queue ***\n\n";
cout << "1. Enqueue Front" << endl;
cout << "2. Enqueue Rear" << endl;
cout << "3. Dequeue Front"<< endl;
cout << "4. Dequeue Rear"<< endl;
cout << "5. Peek Front"<< endl;
cout << "6. Peek Rear"<< endl;
cout << "7. Display the Queue"<< endl;
cout << "8. Exit"<< endl;
cout << "Enter your choice: "<<endl;
cin >> ch;
switch(ch)
{
case 1:
cout<<"Enter An Element:";
cin>>num;
d.EnqueueFront(num);
getch();
break;
case 2:
cout<<"Enter An Element:";
cin>>num;
d.EnqueueRear(num);
getch();
break;
case 3:
d.DequeueFront();
getch();
break;
case 4:
d.DequeueRear();
getch();
break;
case 5:
d.PeekFront();
getch();
break;
case 6:
d.PeekRear();
getch();
break;
case 7:
d.Display();
getch();
break;
case 8:
exit(1);
default:
cout << "Incorect Choice!" << endl;
getch();
break;
}
}
}
----------------------------------------------------------------------------------------------------
4) Priority Queue
#include<iostream>
#include<conio.h>
using namespace std;
/*1.NOde template*/
class PQNode
{
public:
int data;
int priority;
PQNode *next;
};
/*2. Double Ended Queue*/
class PQueue
{
PQNode *front;
PQNode *rear;
public:
PQueue()
{
front=NULL;
rear=NULL;
}
void Enqueue(int x,int p);
void Dequeue();
void PeekFront();
void PeekRear();
void Display();
};
void PQueue ::Enqueue(int x,int p)
{
//Make a node
PQNode *t=new PQNode();
t->data=x;
t->priority=p;
t->next=NULL;
//First node in the Queue
if(front==NULL)
{
front=t;
return;
}
//Ordered Traversal
PQNode *tmp=front;
PQNode *prev;
while(tmp!=NULL && tmp->priority<p)
{
prev=tmp;
tmp=tmp->next;
}
//Insert t in Queue in order of Priority
if(tmp==front)//First node insertion
{
t->next=front;
front=t;
}
else if (tmp==NULL)
{
prev->next=t;
}
else {
prev->next=t;
t->next=tmp;
}
}
void PQueue::Display()
{
if(front ==NULL)
{
cout<<"Queue UnderFLow !";
return;
}
PQNode *tmp =front;
while(tmp!=NULL)
{
cout<<"Data: " <<tmp->data<<" Priority: "<<tmp->priority<<endl;
tmp=tmp->next;
}
}
void PQueue::Dequeue()
{
if(front ==NULL) //empty Queue
{
cout<<"Queue Underflow !";
return;
}
PQNode *tmp=front;
if(front->next==NULL)//Single Node deletion
{
front==NULL;
}
else
{
front=front->next;
}
cout<<"Element Removed: "<<tmp->data;
cout<<"With Priority: "<<tmp->priority;
delete tmp;
}
void PQueue ::PeekFront()
{
if(front ==NULL) //empty Queue
{
cout<<"Queue Underflow !";
return;
}
PQNode *tmp= front;
cout<<"Element at the front is: "<<tmp->data;
cout<<"with Priority: "<<tmp->priority;
}
void PQueue ::PeekRear()
{
if(front ==NULL) //empty Queue
{
cout<<"Queue Underflow !";
return;
}
//traverse till the last
PQNode *tmp= front;
while (tmp->next != NULL)
{
tmp=tmp->next;
}
cout<<"Element at the rear is: "<<tmp->data;
cout<<"with Priority: "<<tmp->priority;
}
int main()
{
int ch,num1,num2;
PQueue p;
while(1)
{
system("cls");
cout << "*** priority_Queue ***\n\n";
cout << "1. Enqueue Front" << endl;
cout << "2. Dequeue Rear"<< endl;
cout << "3. Peek Front"<< endl;
cout << "4. Peek Rear"<< endl;
cout << "5. Display the Queue"<< endl;
cout << "6. Exit"<< endl;
cout << "Enter your choice: "<<endl;
cin >> ch;
switch(ch)
{
case 1:
cout<<"Enter An Element:";
cin>>num1;
cout<<"Enter priority:";
cin>>num2;
p.Enqueue(num1,num2);
getch();
break;
case 2:
p.Dequeue();
getch();
break;
case 3:
p.PeekFront();
getch();
break;
case 4:
p.PeekRear();
getch();
break;
case 5:
 p.Display();
getch();
break;
case 6:
exit(1);
default:
cout << "Incorect Choice!" << endl;
getch();
break;
}
}
}
----------------------------------------------------------------------------------------------------
Trees
----------------------------------------------------------------------------------------------------
1)Binary Search Trees
#include<iostream>
#include<conio.h>
using namespace std;
/* Node Template */
class BSTNode
{
public:
int data;
BSTNode *right;
BSTNode *left;
};
/* 2. BST Template */
class BST
{
BSTNode *root;
int cnt;
public:
BST()
{
root = NULL;
cnt = 0;
}
void Insert(int x);
void Display();
void Inorder(BSTNode *t);
void Preorder(BSTNode *t);
void Postorder(BSTNode *t);
void Count();
void Search(int x);
void FindMax();
void FindMin();
};
/* 3. functions */
//Insert
void BST :: Insert(int x)
{
//make a new node
BSTNode *t = new BSTNode();
t->data = x;
t->left = NULL;
t->right = NULL;
//First node in the BST
if(root == NULL)
{
root = t;
cnt++;
return;
}
//Traverse
BSTNode *tmp = root;
BSTNode *prev = NULL;
while(tmp!=NULL)
{
prev = tmp;
if(x > tmp->data)
{
tmp = tmp->right;
}
else if(x < tmp->data)
{
tmp = tmp->left;
}
else
{
cout << "Duplicate value!";
getch();
return;
}
}
//Attach t to prev
if(x < prev->data)
{
prev->left = t;
}
else
{
prev->right = t;
}
cnt++;
}
//Display
void BST :: Display()
{
if(root == NULL)
{
cout << "Empty Tree!";
return;
}
cout << "Inorder Traversal: ";
Inorder(root);
cout << endl;
cout << "Preorder Traversal: ";
Preorder(root);
cout << endl;
cout << "Postorder Traversal: ";
Postorder(root);
}
//Inorder
void BST :: Inorder(BSTNode *t)
{
if(t)
{
Inorder(t->left);
cout << t->data << " ";
Inorder(t->right);
}
}
//Preorder
void BST :: Preorder(BSTNode *t)
{
if(t)
{
cout << t->data << " ";
Preorder(t->left);
Preorder(t->right);
}
}
//Postorder
void BST :: Postorder(BSTNode *t)
{
if(t)
{
Postorder(t->left);
Postorder(t->right);
cout << t->data << " ";
}
}
//count
void BST :: Count()
{
if(root == NULL)
{
cout << "Empty Tree!";
return;
}
else
{
cout << "Tree contains: " << cnt << " nodes";
}
}
//Search
void BST :: Search(int x)
{
if(root == NULL)
{
cout << "Empty Tree!";
return;
}
BSTNode *tmp = root;
int flag = 0;
while(tmp != NULL)
{
if(x < tmp->data)
{
tmp = tmp->left;
}
else if(x > tmp->data)
{
tmp = tmp->right;
}
else
{
flag = 1;
break;
}
}//end of while
if(flag == 0)
{
cout << x << " is not found!";
}
else
{
cout << x << " is found!";
}
}
//findMax
void BST :: FindMax()
{
if(root == NULL)
{
cout << "Empty Tree!";
return;
}
BSTNode *tmp = root;
while(tmp->right != NULL)
{
tmp = tmp->right;
}
cout << "Maximum value: " << tmp->data;
}
//findMin
void BST :: FindMin()
{
if(root == NULL)
{
cout << "Empty Tree!";
return;
}
BSTNode *tmp = root;
while(tmp->left != NULL)
{
tmp = tmp->left;
}
cout << "Minimum value: " << tmp->data;
}
/* 4. Menu */
int main()
{
int num,ch;
BST b;
while(1)
{
system("cls");
cout << "***Binary Search Trees***\n\n";
cout << "1. Insert" << endl;
cout << "2. Display the BST" << endl;
cout << "3. Count the nodes in the BST" << endl;
cout << "4. Search for the element" << endl;
cout << "5. Find the maximum value" << endl;
cout << "6. Find the minimum value" << endl;
cout << "7. Exit" << endl;
cout << "\nEnter your choice: ";
cin >> ch;
switch(ch)
{
case 1:
cout << "Enter the element: ";
cin >> num;
b.Insert(num);
getch();
break;
case 2:
b.Display();
getch();
break;
case 3:
b.Count();
getch();
break;
case 4:
cout << "Enter the element: ";
cin >> num;
b.Search(num);
getch();
break;
case 5:
b.FindMax();
getch();
break;
case 6:
b.FindMin();
getch();
break;
case 7:
exit(1);
default:
cout << "Incorrect Option!";
getch();
break;
}//end of switch
}//end of while
}//end of main
----------------------------------------------------------------------------------------------------
Max Heap
#include<iostream>
#include<conio.h>
#define MAX 20
using namespace std;
/* 1. Node Template */
/* 2. Heap Template */
class Heap
{
int a[MAX];
int n;
public:
Heap()
{
for(int i = 0; i<MAX; i++ )
{
a[i]=0;
}
n = 0;
}
void BuildHeap();
void Insert(int x);
void DeleteHeap();
void Display();
void reheapDown(int pos);
void reheapUp(int x);
};
/* 3. Function */
void Heap :: BuildHeap()
{
int i;
cout << "Enter the size of the array: ";
cin >> n; // n is declared in Heap Class
cout << "Enter " << n << " values in the Heap" << endl;
for(i = 0; i < n; i++)
{
cin >> a[i];
}
for(i =(n/2)-1; i >=0;i--)
{
reheapDown(i);
}
}
void Heap :: Insert(int x)
{
a[n] = x;
n++;
reheapUp(n-1);
}
void Heap :: reheapUp(int x)
{
int tmp = a[x];
while(a[(x-1)/2] <= tmp && x>0)
{
a[x] = a[(x-1)/2];
x = (x-1)/2;
}
a[x] = tmp;
}
void Heap :: reheapDown(int pos)
{
int tmp = a[pos];
int i;
while(pos <= (n/2)-1 ) // Comparing with last non-leaf position
{
i= (2 * pos) + 1; // Left Child
if(a[i+1] > a[i]) // Compare left and right child
{
i++;
}
if(tmp > a[i])
{
break;
}
a[pos] = a[i];
pos = i;
}
a[pos] = tmp;
}
void Heap :: DeleteHeap()
{
int x = a[0]; //copy root element to x
a[0] = a[n-1]; // copy last element to root
a[n-1] = 0; // Overwrite tle last element with 0
n--; // Decrement size of the heap
reheapDown(0); // ReheapDown from root
cout << "Element deleted is: " << x;
}
void Heap :: Display()
{
int i;
for(i=0;i<n;i++)
{
cout << a[i] << " ";
}
}
/* 4. Main */
int main()
{
int ch, num;
Heap h;
while(1)
{
system("cls");
cout << "*** Max-Heap ***\n\n";
cout << "1. Build a heap"<< endl;
cout << "2. Insert an element" << endl;
cout << "3. Delete" << endl;
cout << "4. Display" << endl;
cout << "5. Exit" << endl;
cout << "Enter your choice: ";
cin >> ch;
switch(ch)
{
case 1:
h.BuildHeap();
getch();
break;
case 2:
cout << "Enter an Element: ";
cin >> num;
h.Insert(num);
getch();
break;
case 3:
h.DeleteHeap();
getch();
break;
case 4:
h.Display();
getch();
break;
case 5:
exit(1);
default:
cout << "Incorect Choice!" << endl;
getch();
break;
}
}
}
----------------------------------------------------------------------------------------------------
Graph
#include<iostream>
#include<conio.h>
#define MAX 10
using namespace std;
/* Node Template-NOT REQUIRED */
/* Graph Template */
class Graph
{
int adj[MAX][MAX];
int n;
int e;
public:
Graph()
{
int i, j;
for(i = 0; i < MAX; i++)
{
for(j = 0; j < MAX; j++)
{
adj[i][j] = 0;
}
}
n = 0; e = 0;
}
void CreateGraph();
void Display();
};
/* Function */
//creategraph
void Graph :: CreateGraph()
{
cout << "Enter the number of nodes: ";
cin >> n; //n is declared in the graph class
cout << "Enter the number of edges: ";
cin >> e; //n is declared in the graph class
int i, source, dest;
for(i = 1; i<=e; i++)
{
cout << "Input Edge " << i << endl;
cout << "Enter source node: ";
cin >> source;
cout << "Enter destination node: ";
cin >> dest;
adj[source][dest]=1;
adj[dest][source]=1;
}
}
//display
void Graph :: Display()
{
int i, j;
for(i = 0; i<n; i++)
{
for(j = 0; j<n; j++)
{
cout << adj[i][j] << " ";
}
cout << endl;
}
}
/* Menu */
int main()
{
int num, ch;
Graph g;
while(1)
{
system("cls");
cout << "*** Graph ***\n\n";
cout << "1. Create a graph" << endl;
cout << "2. Display" << endl;
cout << "3. Exit" << endl;
cout << "\nEnter your choice: ";
cin >> ch;
switch(ch)
{
case 1:
g.CreateGraph();
getch();
break;
case 2:
g.Display();
getch();
break;
case 3:
exit(1);
default:
cout << "Incorrect option!";
getch();
break;
}
}
}
----------------------------------------------------------------------------------------------------
DFS Graph
#include<iostream>
#include<conio.h>
#define MAX 10
using namespace std;
/* stack Template */
class Stack
{
int a[MAX];
int tos;
public:
Stack()
{
tos = -1;
}
void Push(int x);
int Pop();
int Empty();
};
//Push
void Stack :: Push(int x)
{
tos++;
a[tos] = x;
}
int Stack :: Pop()
{
int x = a[tos];
tos--;
return x;
}
int Stack :: Empty()
{
if(tos == -1)
{
return 1;
}
else
{
return 0;
}
}
/* Node Template-NOT REQUIRED */
/* Graph Template */
class Graph
{
int adj[MAX][MAX];
int n;
int e;
int visited[MAX];
public:
Graph()
{
int i, j;
for(i = 0; i < MAX; i++)
{
for(j = 0; j < MAX; j++)
{
adj[i][j] = 0;
}
}
n = 0; e = 0;
}
void CreateGraph();
void Display();
void DFT(int x);
};
/* Function */
void Graph :: CreateGraph()
{
cout << "Enter the number of nodes: ";
cin >> n; //n is declared in the graph class
cout << "Enter the number of edges: ";
cin >> e; //n is declared in the graph class
int i, source, dest;
for(i = 1; i<=e; i++)
{
cout << "Input Edge " << i << endl;
cout << "Enter source node: ";
cin >> source;
cout << "Enter destination node: ";
cin >> dest;
adj[source][dest]=1;
adj[dest][source]=1;
}
}
//display
void Graph :: Display()
{
int i, j;
for(i = 0; i<n; i++)
{
for(j = 0; j<n; j++)
{
cout << adj[i][j] << " ";
}
cout << endl;
}
}
//DFT
void Graph :: DFT(int x)
{
Stack s;
int i;
//update visited to 0
for(i=0; i<n; i++)
{
visited[i] = 0;
}
s.Push(x);
visited[x] = 1;
while(!s.Empty())
{
x = s.Pop();
cout << x << " ";
for(i = 0; i < n; i++)
{
if(adj[x][i]==1 && visited[i]==0)
{
s.Push(i);
visited[i] = 1;
}
}
}
}
/* Menu */
int main()
{
int num, ch;
Graph g;
while(1)
{
system("cls");
cout << "*** DFT of Graph ***\n\n";
cout << "1. Create a graph" << endl;
cout << "2. Display" << endl;
cout << "3. DFT" << endl;
cout << "4. exit" << endl;
cout << "\nEnter your choice: ";
cin >> ch;
switch(ch)
{
case 1:
g.CreateGraph();
getch();
break;
case 2:
g.Display();
getch();
break;
case 3:
cout << "Enter the node: ";
cin >> num;
g.DFT(num);
getch();
break;
case 4:
exit(1);
default:
cout << "Incorrect option!";
getch();
break;
}
}
}
----------------------------------------------------------------------------------------------------
BFS Graph
#include<iostream>
#include<conio.h>
#define MAX 10
using namespace std;
/* Queue Template */
class Queue
{
int a[MAX];
int front, rear;
public:
Queue()
{
front = rear = -1;
}
void Enqueue(int x);
int Dequeue();
int Empty();
};
void Queue::Enqueue(int x)
{
if(front == -1)
{
front++;
}
rear++;
a[rear] = x;
}
int Queue::Dequeue()
{
if(front == -1)
{
cout << "Underflow";
return -1;
}
int x = a[front];
if(front == rear)
{
front = rear = -1;
}
else
{
front++;
}
return x;
}
int Queue::Empty()
{
if(front == -1)
{
return 1;
}
else
{
return 0;
}
}
/* 1. Node Template-Not Required */
/* 2. Graph Template */
class Graph
{
int adj[MAX][MAX];
int n;
int e;
int visited[MAX];
public:
Graph()
{
int i,j;
for(i=0;i<MAX;i++)
{
for(j=0;j<MAX;j++)
{
adj[i][j] = 0;
}
}
n = 0;
e = 0;
}
void CreateGraph();
void Display();
void BST(int x);
};
/* 3. Function */
void Graph :: CreateGraph()
{
cout << "Enter the number of nodes: ";
cin >> n; // n is declared in the Graph Class
cout << "Enter the number of edges: ";
cin >> e; // e is declared in the Graph Class
int i,source,dest;
for(i=1;i<=e;i++)
{
cout << "Input Edge " << i << endl;
cout << "Enter source node: ";
cin >> source;
cout << "Enter destination node: ";
cin >> dest;
adj[source][dest] = 1;
adj[dest][source] = 1;
}
}
void Graph :: Display()
{
int i,j;
for(i=0;i<n;i++)
{
for(j=0;j<n;j++)
{
cout << adj[i][j] << " ";
}
cout << endl;
}
}
void Graph::BST(int x)
{
Queue q;
int i;
//Update visited to 0
for(i=0;i<n;i++)
{
visited[i]=0;
}
q.Enqueue(x);
visited[x] = 1;
while(!q.Empty())
{
x = q.Dequeue();
cout << x << " ";
for(i=0;i<n;i++)
{
if(adj[x][i] == 1 && visited[i] == 0)
{
q.Enqueue(i);
visited[i] = 1;
}
}
}
}
/* 4. Main */
int main()
{
int ch, num;
Graph b;
while(1)
{
system("cls");
cout << "*** Graphs ***\n\n";
cout << "1. Create a Graph"<< endl;
cout << "2. Display a Graph" << endl;
cout << "3. Breadth First Traversal" << endl;
cout << "4. Exit" << endl;
cout << "Enter your choice: ";
cin >> ch;
switch(ch)
{
case 1:
b.CreateGraph();
getch();
break;
case 2:
b.Display();
getch();
break;
case 3:
cout << "Enter the node: ";
cin >> num;
b.BST(num);
getch();
break;
case 4:
exit(1);
default:
cout << "Incorect Choice!" << endl;
getch();
break;
}
}
}
----------------------------------------------------------------------------------------------------
MST using Kruskal's Algorithm
#include<iostream>
#include<conio.h>
#define MAX 10
#define INF 999
using namespace std;
/* Node Template-NOT REQUIRED */
/* Graph Template */
class Graph
{
int adj[MAX][MAX];
int n;
int e;
int parent[MAX];
public:
Graph()
{
int i, j;
for(i = 0; i < MAX; i++)
{
for(j = 0; j < MAX; j++)
{
adj[i][j] = INF;
}
}
n = 0; e = 0;
for(i=0; i<MAX; i++)
{
parent[i] = -1;
}
}
void CreateGraph();
void Display();
void Kruskal();
int Find(int x);
int Union(int x, int y);
};
/* Function */
//creategraph
void Graph :: CreateGraph()
{
cout << "Enter the number of nodes: ";
cin >> n; //n is declared in the graph class
cout << "Enter the number of edges: ";
cin >> e; //n is declared in the graph class
int i, source, dest, weight;
for(i = 1; i<=e; i++)
{
cout << "Input Edge " << i << endl;
cout << "Enter source node: ";
cin >> source;
cout << "Enter destination node: ";
cin >> dest;
cout << "Enter the weight: ";
cin >> weight;
adj[source][dest] = weight;
adj[dest][source] = weight;
}
}
//display
void Graph :: Display()
{
int i, j;
for(i = 0; i<n; i++)
{
for(j = 0; j<n; j++)
{
if(adj[i][j] == INF)
{
cout << "0 ";
}
else
{
cout << adj[i][j] << " ";
}
}
cout << endl;
}
}
void Graph :: Kruskal()
{
int minimum, i, j, ne = 1;
int a, b, u, v;
int mincost = 0;
while(ne < n)
{
for(i = 0, minimum = 999; i<n; i++)
{
for(j=0; j<n; j++)
{
if(adj[i][j] < minimum)
{
minimum = adj[i][j];
a = u = i;
b = v = j;
}//end of if
}//end of j
}//end of for i
u = Find(u);
v = Find(v);
if(Union(u,v))
{
cout << "Edge " << ne++ << " (" << a << "," << b << ") = " << minimum << endl;
mincost += minimum;
}
adj[a][b] = adj[b][a] = INF;
}//end of while loop
cout << "MST Minimum Cost = " << mincost;
}
int Graph :: Find(int x)
{
while(parent[x] != -1)
{
x = parent[x];
}
return x;
}
int Graph :: Union(int x, int y)
{
if(x!=y)
{
parent[y] = x;
return 1;
}
}
/* Menu */
int main()
{
int num, ch;
Graph g;
while(1)
{
system("cls");
cout << "*** MST using Kruskal's Algorithm ***\n\n";
cout << "1. Create a graph" << endl;
cout << "2. Display" << endl;
cout << "3. MST using Kruskal's Algorithm" << endl;
cout << "4. Exit" << endl;
cout << "\nEnter your choice: ";
cin >> ch;
switch(ch)
{
case 1:
g.CreateGraph();
getch();
break;
case 2:
g.Display();
getch();
break;
case 3:
g.Kruskal();
getch();
break;
case 4:
exit(1);
default:
cout << "Incorrect option!";
getch();
break;
}
}
}
----------------------------------------------------------------------------------------------------
Graph Storage Structure Adjacency Matrix
//Program :Graph Storage Structure -AdjacencyMatrix
#include<iostream>
#include<conio.h>
#define MAX 10
using namespace std;
/* Node template */
/* Queue Template */
class Graph
{
int adj[MAX][MAX];
int n;
int e;
public:
Graph()
{
int i,j;
for(i-0; i<MAX; i++)
{
for(j=0; j<MAX; j++)
{
adj[i][j]=0;
}
}
n=0;e=0;
}
void CreateGraph();
void Display();
};
/*3.Function*/
void Graph::CreateGraph()
{
cout<<"enter the number of nodes: ";
cin>>n; //n is declare in the graph Class don't declare locally
cout<<"enter the number of edges: ";
cin>>e; //e is declare in the graph Class don't declare locally
int i,source, dest;
for(i=1; i<=e; i++)
{
cout<<"Input Edge"<<i<<endl;
cout<<"Enter Source Node:";
cin>>source;
cout<<"Enter Source Node:";
cin>>dest;
adj[source][dest]=1;
adj[dest][source]=1;
}
}
void Graph ::Display()
{
int i,j;
for(i=0; i<n; i++)
{
for(j=0; j<n; j++)
{
cout<<adj[i][j]<<" ";
}
cout<<endl;
}
}
int main()
{
int ch,num;
 Graph g;
while(1)
{
system("cls");
cout<<"**Graph**"<<endl;
cout <<"1.Create "<<endl;
cout <<"2.Display"<<endl;
cout <<"3.DFS"<<endl;
cout << "Enter your choice: ";
cin >> ch;
switch(ch)
{
case 1:
 g.CreateGraph();
 getch();
 break;
case 2:
 g.Display();
 getch();
 break;
case 3:
 exit(1);
default:
 cout << "Incorect Choice!" << endl;
 getch();
 break;
}
}
}
----------------------------------------------------------------------------------------------------
Modulo Division Hashing with Linear Probe for Collision Resolution
#include <iostream>
#include <conio.h>
using namespace std;
#define MAX 10
#define EMPTY -1
//1. Node Template - NOT REQUIRED
//2. Hash Table Template
class Hashing
{
int h[MAX];
public:
Hashing()
{
for (int i = 0; i < MAX; i++)
{
h[i] = EMPTY;
}
} //end of constructor
//3. Function
void Insert(int value)
{
int add = value % MAX, oadd = add;
if (h[add] == EMPTY)
{
h[add] = value;
}
else
{
while (h[add] != EMPTY)
{
add = (add + 1) % MAX;
if (add == oadd)
{
cout << "The hash Map is Full" << endl;
return;
}
}
h[add] = value;
cout << "Value is inserted" << endl;
}
}
void Display()
{
for (int i = 0; i < MAX; i++)
{
cout << "h[" << i << "] = " << h[i] << endl;
}
}
void Search(int target)
{
int sadd = target % MAX; //Modulo Division Calculation - HASH Function
if (h[sadd] == target)
{
cout << "Value is Found!" << endl;
}
else
{
int soadd = sadd;
while (h[sadd] != target)
{
sadd = (sadd + 1) % MAX;
if (sadd == soadd)
{
cout << "Value not found" << endl;
return;
}
}
cout << "Value Found!" << endl;
}
}
}; //end of Hash Template
//Menu
int main()
{
int num, ch;
Hashing h;
while (1)
{
system("cls");
cout << "*** Hashing using Modulo Division and Linear Probe ***\n\n";
cout << "1.Insert an element in the Hash Table" << endl;
cout << "2.Display the Hash Table" << endl;
cout << "3.Search for an element" << endl;
cout << "4.Exit" << endl
<< endl;
cout << "Please enter your choice: ";
cin >> ch;
switch (ch)
{
case 1:
cout << endl
<< "Enter a value to insert into the hash table: ";
cin >> num;
h.Insert(num);
getch();
break;
case 2:
h.Display();
getch();
break;
case 3:
cout << endl
<< "Enter a value to search in the hash table: ";
cin >> num;
h.Search(num);
getch();
break;
case 4:
exit(1);
default:
cout << "Please choose an option between 1 to 4!";
getch();
} // end of switch
}//end of while
}// end of main
----------------------------------------------------------------------------------------------------
Digit Extraction Hashing with Linear Probe for Collision Resolution
#include <iostream>
#include <conio.h>
using namespace std;
#define MAX 100
#define EMPTY -1
//1. Node Template - NOT REQUIRED
//2. Hash Table Template
class Hashing
{
int h[MAX];
public:
Hashing()
{
for (int i = 0; i < MAX; i++)
{
h[i] = EMPTY;
}
} //end of constructor
//3. Function
void Insert(int value)
{
int add = (value % 100 - value % 10) + ((value % 100000 - value % 10000) /
10000), oadd = add;
if (h[add] == EMPTY)
{
h[add] = value;
}
else
{
while (h[add] != EMPTY)
{
add = (add + 1) % MAX;
if (add == oadd)
{
cout << "The hash Map is Full" << endl;
return;
}
}
h[add] = value;
cout << "Value is inserted" << endl;
}
}
void Display()
{
for (int i = 0; i < MAX; i++)
{
if(h[i] == -1) {
continue;
} else {
cout << "h[" << i << "] = " << h[i] << endl;
}
}
}
void Search(int target)
{
int sadd = (target % 100 - target % 10) + ((target % 100000 - target % 10000) / 10000);
if (h[sadd] == target)
{
cout << "Value is Found!" << endl;
}
else
{
int soadd = sadd;
while (h[sadd] != target)
{
sadd = (sadd + 1) % MAX;
if (sadd == soadd)
{
cout << "Value not found" << endl;
return;
}
}
cout << "Value Found!" << endl;
}
}
}; //end of Hash Template
//Menu
int main()
{
int num, ch;
Hashing h;
while (1)
{
system("cls");
cout << "*** Hashing using Digit Extraction and Linear Probe ***\n\n";
cout << "1.Insert an element in the Hash Table" << endl;
cout << "2.Display the Hash Table" << endl;
cout << "3.Search for an element" << endl;
cout << "4.Exit" << endl
<< endl;
cout << "Please enter your choice: ";
cin >> ch;
switch (ch)
{
case 1:
cout << endl
<< "Enter a value to insert into the hash table: ";
cin >> num;
h.Insert(num);
getch();
break;
case 2:
h.Display();
getch();
break;
case 3:
cout << endl
<< "Enter a value to search in the hash table: ";
cin >> num;
h.Search(num);
getch();
break;
case 4:
exit(1);
default:
cout << "Please choose an option between 1 to 4!";
getch();
} // end of switch
}//end of while
}// end of main
----------------------------------------------------------------------------------------------------
Fold Shift Hashing with Linear Probe for Collision Resolution
#include <iostream>
#include <conio.h>
using namespace std;
#define MAX 100
#define EMPTY -1
//1. Node Template - NOT REQUIRED
//2. Hash Table Template
class Hashing
{
int h[MAX];
public:
Hashing()
{
for (int i = 0; i < MAX; i++)
{
h[i] = EMPTY;
}
} //end of constructor
//3. Function
void Insert(int val)
{
int add = 0, oadd = 0, value = val;
while(val > 0) {
add += val % 100;
val /= 100;
} int carry =
add /
100;
add += carry * 10;
oadd = add;
if (h[add] == EMPTY)
{
h[add] = value;
}
else
{
while (h[add] != EMPTY)
{
add = (add + 1) % MAX;
if (add == oadd)
{
cout << "The hash Map is Full" << endl;
return;
}
}
h[add] = value;
cout << "Value is inserted" << endl;
}
}
void Display()
{
for (int i = 0; i < MAX; i++)
{
if(h[i] == -1) {
continue;
} else {
cout << "h[" << i << "] = " << h[i] << endl;
}
}
}
void Search(int target)
{
int sadd = 0,value = target;
while(target > 0) {
sadd += target % 100;
target /= 100;
} int carry =
sadd /
100;
sadd += carry * 10;
if (h[sadd] == value)
{
cout << "Value is Found!" << endl;
}
else
{
int soadd = sadd;
while (h[sadd] != value)
{
sadd = (sadd + 1) % MAX;
if (sadd == soadd)
{
cout << "Value not found" << endl;
return;
}
}
cout << "Value Found!" << endl;
}
}
}; //end of Hash Template
//Menu
int main()
{
int num, ch;
Hashing h;
while (1)
{
system("cls");
cout << "*** Hashing using Fold Shift and Linear Probe ***\n\n";
cout << "1.Insert an element in the Hash Table" << endl;
cout << "2.Display the Hash Table" << endl;
cout << "3.Search for an element" << endl;
cout << "4.Exit" << endl
<< endl;
cout << "Please enter your choice: ";
cin >> ch;
switch (ch)
{
case 1:
cout << endl
<< "Enter a value to insert into the hash table: ";
cin >> num;
h.Insert(num);
getch();
break;
case 2:
h.Display();
getch();
break;
case 3:
cout << endl
<< "Enter a value to search in the hash table: ";
cin >> num;
h.Search(num);
getch();
break;
case 4:
exit(1);
default:
cout << "Please choose an option between 1 to 4!";
getch();
} // end of switch
}//end of while
}// end of main
----------------------------------------------------------------------------------------------------
Fold Boundary Hashing with Linear Probe for Collision Resolution
#include <iostream>
#include <conio.h>
using namespace std;
#define MAX 100
#define EMPTY -1
//1. Node Template - NOT REQUIRED
//2. Hash Table Template
class Hashing
{
int h[MAX];
public:
Hashing()
{
for (int i = 0; i < MAX; i++)
{
h[i] = EMPTY;
}
} //end of constructor
//3. Function
void Insert(int value)
{
int add = 0, oadd = add;
int part1 = rev((value % 1000000)/10000);
int part2 = (value % 10000)/100;
int part3 = rev(value % 100);
add = (part1 + part2 + part3) % MAX;
if (h[add] == EMPTY)
{
h[add] = value;
}
else
{
while (h[add] != EMPTY)
{
add = (add + 1) % MAX;
if (add == oadd)
{
cout << "The hash Map is Full" << endl;
return;
}
}
h[add] = value;
cout << "Value is inserted" << endl;
}
}
void Display()
{
for (int i = 0; i < MAX; i++)
{
if(h[i] == -1) {
continue;
} else {
cout << "h[" << i << "] = " << h[i] << endl;
}
}
}
void Search(int target)
{
int sadd = 0;
int part1 = rev((target % 1000000)/10000);
int part2 = (target % 10000)/100;
int part3 = rev(target % 100);
sadd = (part1 + part2 + part3) % MAX;
if (h[sadd] == target)
{
cout << "Value is Found!" << endl;
}
else
{
int soadd = sadd;
while (h[sadd] != target)
{
sadd = (sadd + 1) % MAX;
if (sadd == soadd)
{
cout << "Value not found" << endl;
return;
}
}
cout << "Value Found!" << endl;
}
}
int rev(int num) {
int r = 0;
while(num > 0) {
r = r * 10 + num % 10;
num /= 10;
} return r;
}
}; //end of Hash Template
//Menu
int main()
{
int num, ch;
Hashing h;
while (1)
{
system("cls");
cout << "*** Hashing using Fold Boundary and Linear Probe ***\n\n";
cout << "1.Insert an element in the Hash Table" << endl;
cout << "2.Display the Hash Table" << endl;
cout << "3.Search for an element" << endl;
cout << "4.Exit" << endl
<< endl;
cout << "Please enter your choice: ";
cin >> ch;
switch (ch)
{
case 1:
cout << endl
<< "Enter a value to insert into the hash table: ";
cin >> num;
h.Insert(num);
getch();
break;
case 2:
h.Display();
getch();
break;
case 3:
cout << endl
<< "Enter a value to search in the hash table: ";
cin >> num;
h.Search(num);
getch();
break;
case 4:
exit(1);
default:
cout << "Please choose an option between 1 to 4!";
getch();
} // end of switch
}//end of while
}// end of main
----------------------------------------------------------------------------------------------------
